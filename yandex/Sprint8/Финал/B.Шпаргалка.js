/*
https://contest.yandex.ru/contest/26133/run-report/115387875/

-- ПРИНЦИП РАБОТЫ --
Алгоритм разбиения строки на слова из входного словаря базируется на идее динамического программирования
с использованием префиксного дерева (Trie). 

Сначала создается префиксное дерево, где каждый узел содержит значение, ссылки на следующие узлы и флаг терминальности, указывающий конец слова. 

Для каждой строки из словаря создается соответствующий путь в дереве, и узел, заканчивающийся последним символом строки, 
помечается как терминальный. 

Алгоритм использует динамическое программирование для проверки возможности разбиения строки string на слова из набора strings. 
Массив dp хранит состояние, где dp[i] равно true, если подстроку можно разбить на слова из словаря. 
Для каждого символа строки проверяются все возможные подстроки. Если подстрока заканчивается на терминальном узле, 
соответствующая позиция в dp помечается как true.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Корректность алгоритма обеспечивается методом заполнения массива динамического программирования dp.
Каждый элемент этого массива содержит булево значение, указывающее на возможность разбиения строки до этой позиции на слова из словаря. 
Последовательное заполнение массива dp гарантирует, что если существует разбиение строки string на слова из словаря, 
то последний элемент массива dp будет равен true.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Временная сложность алгоритма составляет cоздание и прохождение по префиксному дереву для проверки каждой подстроки.
Шаг создания дерева (Trie): O(L), где L — суммарная длина всех строк в наборе. 
Это время затрачивается на построение структуры данных (префиксного дерева), используемой для быстрой проверки разбиения строки.
Шаг проверки разбиения строки: O(N * T), где N — количество строк в наборе, T — максимальная длина строки в наборе. 
Это время затрачивается на проверку каждого символа строки на наличие соответствующего пути в префиксном дереве.

Итак, общая временная сложность алгоритма будет составлять O(L + N * T), где L — суммарная длина всех строк в наборе,
N — количество строк в наборе, T — максимальная длина строки в наборе.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Использование префиксных деревьев (Trie) является эффективным способом хранения и обработки наборов строк с ограниченным алфавитом символов. 
Каждая нода в Trie может иметь не более ∣Σ∣ потомков, где ∣Σ∣ — размер алфавита. Таким образом, количество узлов в дереве ограничено выражением ∣Σ∣ ^ H, 
где H — максимальная длина слова в наборе строк.

Префиксные деревья эффективно используют память, благодаря повторному использованию общих префиксов строк. 
Это особенно ценно при работе с наборами строк, где максимальная длина слова H и размер алфавита ∣Σ∣ ограничены. 

Например, для алфавита из трёх букв (a, b, c) и максимальной длины слова H = 4, дерево будет содержать не более 81 узла, 
что значительно экономит память по сравнению с хранением каждого слова отдельно.

Таким образом, пространственная сложность Trie составляет O(∣Σ∣ ^ H), что позволяет эффективно управлять потреблением памяти в зависимости от характеристик входных данных.
*/

const readline = require("readline");

const reader = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    terminal: false
});

const Answers = {
    YES: 'YES',
    NO: 'NO',
};

const { YES, NO } = Answers;

const LINE = 'line';
const CLOSE = 'close';

const inputLines = [];
let curLine = 0;

// чтение строк из стандартного ввода
reader.on(LINE, line => inputLines.push(line));
reader.on(CLOSE, solve);

// Функция для чтения числа из входных данных
const readNumber = () => Number(inputLines[curLine++]);
// Функция для чтения строки из входных данных
const readString = () => inputLines[curLine++];
// Функция для чтения массива строк из входных данных
const readStringArray = (n) => {
    const strings = [];

    for (let k = 0; k < n; k++)
        strings.push(inputLines[curLine++]);

    return strings;
}

class Node {
    constructor(value) {
        this.value = value;
        this.next = {};
        this.terminal = false; // Флаг терминальности, указывающий конец слова
    }
}

// Функция для создания префиксного дерева из набора строк
function createTree(strings) {
    const root = new Node('');

    for (const string of strings) {
        let node = root;

        for (const char of string) {
            if (!node.next[char]) node.next[char] = new Node(char);

            node = node.next[char];
        }

        node.terminal = true; // Устанавливаем терминальность узла
    }
    return root;
}

// Функция, определяющая, можно ли разбить строку t на слова из набора strings
const getAnswer = (string, strings) => {
    const root = createTree(strings);
    const dp = Array(string.length + 1).fill(false); // Массив для хранения динамического состояния

    dp[0] = true; // Пустую строку всегда можно разбить

    for (let i = 0; i < string.length; i++) {
        if (dp[i]) {
            let node = root;

            for (let j = i; j < string.length; j++) {

                if (!node.next[string[j]]) break; // Если нет следующего узла, выходим из цикла

                node = node.next[string[j]];

                if (node.terminal) dp[j + 1] = true; // Если узел терминальный, помечаем позицию
            }
        }
    }

    // Если dp[string.length] === true, выводим "YES", иначе "NO"
    console.log(dp[string.length] ? YES : NO);
}

// Главная функция, читающая входные данные и вызывающая getAnswer
function solve() {
    // Читаем строку t
    const t = readString();
    // Читаем количество строк в наборе
    const n = readNumber();
    // Читаем сами строки набора
    const strings = readStringArray(n);

    // Вызываем функцию для определения ответа
    getAnswer(t, strings);
}