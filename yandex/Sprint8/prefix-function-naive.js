let n = s.length;
// Создаем массив π, состоящий из N нулей.
let pi = new Array(n).fill(0);

for (let i = 1; i <= n; ++i) {
    // i — длина подстроки-префикса.
    let substring = s.substring(0, i);
    // Проверяем, перекрывается ли подстрока substring с собой по k символам.
    for (let k = i - 1; k > 0; --k) {
        // Для этого сравним префикс и суффикс соответствующих длин.
        let prefix = substring.substring(0, k);
        let suffix = substring.substring(i - k, i);
        if (prefix === suffix) {
            pi[i - 1] = k; // Запишем значение π-функции.
            break; // Дальше не проверяем — k идет в порядке уменьшения.

        }
    }
}

/*
Посчитаем сложность этого алгоритма. Фактически, в нём содержится три цикла:

Внешний цикл перебирает длину i подстроки-префикса s[0,i) от 1 до N. 

Внутренний цикл итерируется по длине k префикса s[0,k) и суффикса s[i−k,i) получившейся подстроки. 

Во внутреннем цикле неявно спрятан ещё один — посимвольное сравнение строк, которое выполняется за O(k).

Всё вместе это даёт кубическую сложность O(N^3), что неприемлемо для длинных строк.

Однако можно посчитать префикс-функцию гораздо эффективнее, воспользовавшись методами динамического программирования. */