const _readline = require('readline');

const _reader = _readline.createInterface({
    input: process.stdin
});

const _inputLines = [];
let _curLine = 0;

// Установим callback на считывание строки - так мы получим
// все строки из ввода в массиве _inputLines.
_reader.on('line', line => {
    _inputLines.push(line);
});

// Когда ввод закончится, будет вызвана функция solve.
process.stdin.on('end', solve);

function readNumber() {
    return Number(_inputLines[_curLine++]);
}

// Функция парсит число из очередной строки массива _inputLines
// и сдвигает указатель на единицу вперёд.
function readArrayNumber() {
    return _inputLines[_curLine++].split(' ').map(i => Number(i));
}

/*
Формула n * (n-1) / 2  используется для вычисления количества пар объектов, которые можно составить из набора из  n  элементов.
Это классическая комбинаторная формула для выбора 2 элементов из  n  без учета порядка (комбинации без повторений).

Некоторые примеры, где используется эта формула:

    •	Количество рёбер в полном графе с  n  вершинами. Полный граф — это граф, в котором каждая пара вершин соединена ребром.
    •	Количество рукопожатий на встрече, если каждый участник пожимает руку каждому другому.
    •	Количество возможных пар в наборе из  n  объектов (например, пар студентов для проектов).

Формула исходит из того, что у каждого элемента есть  n - 1  возможностей для создания пары, а деление на 2 устраняет дублирование (A с B и B с A — это одна и та же пара).
*/

function solveNoEffective() {
    const islands = readNumber();
    const squares = readArrayNumber();
    const k = readNumber();
    const diffs = [];

    // Вычисляем разницы для всех пар островов
    for (let i = 0; i < islands; i++) {
        for (let j = i + 1; j < islands; j++) {
            diffs.push(Math.abs(squares[i] - squares[j]));
        }
    }

    // Сортируем разницы и выводим k-ю по порядку, возрастание должно быть asc
    diffs.sort((a, b) => a - b);

    // Выводим k-ю минимальную разницу (k - 1, так как индексация начинается с 0)
    console.log(diffs[k - 1]);
}

function countPairsWithDiffLessThanOrEqualTo(mid, areas) {
    let count = 0;
    let j = 0;
    for (let i = 0; i < areas.length; i++) {
        while (j < areas.length && areas[j] - areas[i] <= mid) {
            j++;
        }
        count += j - i - 1; // Пары (i, j)
    }
    return count;
}

function solve() {
    const n = readNumber();
    const areas = readArrayNumber();
    const k = readNumber();

    // Сортируем массив
    areas.sort((a, b) => a - b);

    // Задаём границы для бинарного поиска
    let low = 0;
    let high = areas[n - 1] - areas[0];

    // Бинарный поиск по разнице
    while (low < high) {
        const mid = Math.floor((low + high) / 2);

        // Подсчитываем количество пар с разницей <= mid
        const count = countPairsWithDiffLessThanOrEqualTo(mid, areas);

        if (count < k) {
            low = mid + 1; // Если меньше k пар, ищем в правой половине
        } else {
            high = mid; // Иначе ищем в левой
        }
    }

    console.log(low);
}

/*
Пример:

Массив  [1, 3, 5] , и  k = 3 .

    1.	Инициализация:
    •	Минимальная возможная разница:  low = 0 .
    •	Максимальная возможная разница:  high = 4  (разница между 1 и 5).
    2.	Первый шаг бинарного поиска:
    •	Вычисляем  mid = (0 + 4)/2 = 2 .
    •	Теперь нужно посчитать, сколько пар имеют разницу  <= 2 .
Для этого перебираем массив:
    •	Для  i = 0  (то есть  areas[0] = 1 ):
    •	 j = 1 :  |1 - 3| = 2 , подходит.
    •	 j = 2 :  |1 - 5| = 4 , не подходит. Останавливаемся для этого  i .
    •	Для  i = 1  (то есть  areas[1] = 3 ):
    •	 j = 2 :  |3 - 5| = 2 , подходит.
    •	Мы нашли две пары с разницей  <= 2 :  |1 - 3|  и  |3 - 5| .
Так как  2 < k = 3 , нам нужно искать большие разницы, и увеличиваем нижнюю границу:  low = 3 .
    3.	Второй шаг бинарного поиска:
    •	Теперь  mid = \frac{3 + 4}{2} = 3 .
    •	Посчитаем количество пар с разницей  <= 3 :
Перебираем массив снова:
    •	Для  i = 0 :
    •	 j = 1 :  |1 - 3| = 2 , подходит.
    •	 j = 2 :  |1 - 5| = 4 , не подходит, остановились.
    •	Для  i = 1 :
    •	 j = 2 :  |3 - 5| = 2 , подходит.
Мы всё ещё находим 2 пары. Это меньше, чем  k = 3 , значит, продолжаем искать в более большом диапазоне и увеличиваем  low  до 4.
    4.	Третий шаг бинарного поиска:
    •	Теперь  low = high = 4 .
    •	Так как  low  равно  high , это и есть наш ответ: третья минимальная разница равна 4.

Почему подсчёт эффективен:

    1.	Отсортированность массива позволяет не перебирать каждую пару, а остановиться, как только разница станет больше текущего значения mid.
    2.	Бинарный поиск на каждой итерации делит диапазон возможных значений разницы пополам, что значительно уменьшает количество операций.
    3.	Каждый раз мы только подсчитываем количество подходящих пар, а не сохраняем все пары в памяти.

Вывод:

Хотя на первый взгляд кажется, что с увеличением  mid  мы перебираем больше значений, 
на самом деле мы ограничиваем количество операций благодаря сортировке и раннему выходу из цикла. 
Бинарный поиск сводит количество проверок к  O(\log D), 
где  D  — диапазон значений разницы, а подсчёт пар работает за  O(n)  для каждого шага поиска, 
что делает общее решение эффективным даже для больших массивов.
*/