function twoSum(numbers, X) {
    for (let i = 0; i < numbers.length; i++) {
        for (let j = i + 1; j < numbers.length; j++) {
            if (numbers[i] + numbers[j] === X) {
                return [numbers[i], numbers[j]];
            }
        }
    }
    return [null, null]; // Если пара не найдена
}

// Пример использования:
const numbers = [2, 7, 11, 15];
const X = 9;
console.log(twoSum(numbers, X)); // Вывод: [2, 7]

/*
Давайте рассмотрим пример, чтобы лучше понять, как работает алгоритм, и почему внутренний цикл начинается с i+1.

Предположим, у нас есть массив чисел numbers = [2, 7, 11, 15], и нам нужно найти пару чисел, сумма которых равна X = 9.

### Поиск пары с использованием описанного алгоритма

1. Первый внешний цикл (i = 0)
   - numbers[i] = 2
   - Внутренний цикл начинается с j = i + 1 = 1
     - numbers[j] = 7, проверяем: 2 + 7 == 9. Условие выполняется, значит возвращаем (2, 7).

Таким образом, алгоритм находит пару (2, 7) и останавливается, так как условие выполнено.

### Почему внутренний цикл начинается с i + 1?

Теперь давайте рассмотрим, почему внутренний цикл начинается с i + 1, а не с 0.

Если бы внутренний цикл начинался с 0, то:

1. Первый внешний цикл (i = 0)
   - numbers[i] = 2
   - Внутренний цикл начинается с j = 0
     - j = 0, numbers[0] + numbers[0] = 2 + 2 = 4, не равно 9.
     - j = 1, numbers[0] + numbers[1] = 2 + 7 = 9. Условие выполняется, возвращаем (2, 7).

На этом этапе уже видим, что не имеет смысла сравнивать numbers[i] с самим собой, т.к. сумма двух одинаковых элементов не может удовлетворять условию (если они не равны половине X).

2. Следующие итерации
   - i = 1, numbers[1] = 7, внутренний цикл начинается с j = 1
     - j = 1, numbers[1] + numbers[1] = 7 + 7 = 14, не равно 9.
     - j = 2, numbers[1] + numbers[2] = 7 + 11 = 18, не равно 9.
     - j = 3, numbers[1] + numbers[3] = 7 + 15 = 22, не равно 9.

Продолжая итерации, можем заметить, что проверка при j <= i не даёт новых пар, т.к. они были бы уже проверены ранее в других комбинациях.

### Заключение

Запуск внутреннего цикла с i + 1 улучшает эффективность алгоритма, исключая лишние сравнения, и упрощает реализацию, поскольку не нужно обрабатывать случаи, когда i == j. 
Это особенно важно, когда numbers содержит много элементов, так как сокращает количество итераций почти в два раза.
*/